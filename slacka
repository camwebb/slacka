#!/usr/bin/gawk -f

# Slacka: an Awk (Gawk) client for Slack
# https://github.com/camwebb/slacka
# (c) Cam Webb <cw@camwebb.info>
# License: The Unlicense <http://unlicense.org/>

@load "json" 

BEGIN{

  # Control logic:

  if ((ARGC == 2) && (ARGV[1] == "cfg")) {
    system("emacs " ENVIRON["HOME"] "/.config/slacka/config.json &")
    exit 0
  }
  else if ((ARGC == 2) && (ARGV[1] == "auth"))
    auth()
  
  config()

  # admin functions
  if (ARGC == 2) {
    if (ARGV[1] == "users")
      make_users()
    else if (ARGV[1] == "check")
     ck_new()
    else if (ARGV[1] == "chans")
      list_channels()
    # no keyword: assume intention to list channel
    else if (!ChanID[ARGV[1]])
      error("no such channel label") 
    else
      list_conv(ChanTeam[ARGV[1]], ChanID[ARGV[1]])
  }
  else if (ARGC == 3) {
    # all two argument commands begin with channel
    if (!ChanID[ARGV[1]])
      error("no such channel label")
    else if (ARGV[2] == "chans")
      list_channels(ChanTeam[ARGV[1]])
    else if (ARGV[2] ~ /^[0-9]+\.[0-9]+$/)
      thread(ChanTeam[ARGV[1]], ChanID[ARGV[1]], ARGV[2])
    else if (ARGV[2] ~ /^\/[^/]+\/$/)
      find(ChanTeam[ARGV[1]], ChanID[ARGV[1]],
           gensub(/^\/([^/]+)\/$/,"\\1","G", ARGV[2]))
    # attempt to post
    else
      post(ChanTeam[ARGV[1]], ChanID[ARGV[1]], "new", ARGV[3])
  }

  else if (ARGC == 4) {
    if (ARGV[1] == "newim")
      newim(ARGV[2], ARGV[3])
    
    else if (!ChanID[ARGV[1]])
      error("no such channel label")
    else if (ARGV[2] !~ /^[0-9]+\.[0-9]+$/)
      error("second argument must be time stamp")

    # rections:
    else if (ARGV[3] ~ /^:[a-z0-9_+]+:$/)
      react(ChanTeam[ARGV[1]], ChanID[ARGV[1]], ARGV[2],
            gensub(/:/,"","G",ARGV[3]))
    else 
      post(ChanTeam[ARGV[1]], ChanID[ARGV[1]], ARGV[2], ARGV[3])
  }

  else {
    print "Usage:\n  Maintenance: slacka auth  | cfg | users | \n"\
      "                       [ <channel> ] chans | newim <t> <u>"
    print "  Check new:   slacka check"
    print "  Read:        slacka <channel> [ <thread_id> ]    "
    print "  Write:       slacka <channel> [ <thread_id> ] \"your message\""
    print "  React:       slacka <channel> <thread_id> :<emoji>:"
      " \"your message\""
    print "  Search:      slacka <channel>  \"/search term/\""
    mychans = "    My chans:"
    PROCINFO["sorted_in"] = "@ind_str_asc"
    for (i in ChanID)
      mychans = mychans " " i
    msg_block(mychans)
    exit 0
  }
}

function newim(team, users,      cmd) {

  if ((team !~ /^T[A-Z0-9]+$/) ||               \
      (users !~ /^U[A-Z0-9,]+$/))
    error("arg 2 must be: 'TXXXX' & arg 3: 'UXXXX[,UXXXX,...]'")
  
  cmd = "curl -L -s "                                                   \
    "-H 'Authorization: Bearer " Token[team]  "' "                      \
    "'https://slack.com/api/conversations.open?users=" users "'"

  DEBUG = 1
  if (api(cmd))
    error("create new IM failed")

  print "New IM channel: " Data["channel"]["id"]
  exit 0
}

function react(team, channel, ts, rtype,      cmd) {
  # https://github.com/iamcal/emoji-data -> emoji.json -> short_name
  # :smile: SMILING FACE WITH OPEN MOUTH AND SMILING EYES ðŸ˜„
  # :+1:, :thumbsup: THUMBS UP SIGN ðŸ‘
  cmd = "curl -X POST -L -s "                                     \
    "-H 'Authorization: Bearer " Token[team]  "' "                \
    "-H 'Content-type: application/x-www-form-urlencoded' "       \
    "--data-urlencode 'channel=" channel "' "                     \
    "--data-urlencode \"name=" rtype "\" "                        \
    "--data-urlencode 'timestamp=" ts "' "
  cmd = cmd "https://slack.com/api/reactions.add"

  if (api(cmd))
    error("reaction failed")

  print "Success"
  exit 0
}

function post(team, channel, ts, text,      cmd, newts, \
              status, lts, lrep, json, data) {
  cmd = "curl -X POST -L -s "                                     \
    "-H 'Authorization: Bearer " Token[team]  "' "                \
    "-H 'Content-type: application/x-www-form-urlencoded' "       \
    "--data-urlencode 'channel=" channel "' "                     \
    "--data-urlencode \"text=" text "\" "    
  if (ts != "new")
    cmd = cmd "--data-urlencode 'thread_ts=" ts "' "
  cmd = cmd "https://slack.com/api/chat.postMessage"

  if (api(cmd))
    error("posting failed")
  print "Posting: success"

  # only add to latest if the channel is being checked
  if (SkipC[channel])
    exit 0
  
  read_latest()

  # make new latest json, updating as appropriate
  json = "["
  for (i in Latest) {
    if (Latest[i]["id"] == channel) {
      # if a new post, the channel's latest is now this post
      if (ts == "new") {
        Latest[i]["ts"] = Data["ts"]
        Latest[i]["replies"] = 0
      }
      # if a reply, and if it's still the latest post, add a reply  
      else if (Latest[i]["ts"] == ts)
        Latest[i]["replies"]++
    }

    json = json "{\"id\":\"" Latest[i]["id"] "\",\"ts\":\"" Latest[i]["ts"] \
      "\",\"replies\":\"" Latest[i]["replies"] "\"},"
  }
  gsub(/.$/,"]",json)
  print json > (ENVIRON["HOME"] "/.config/slacka/latest.json")
  
  # write to log file
  print "Time: " strftime() "\n"                                        \
    "Team: " team "\n"                                                  \
    "Chan: " channel "\n"                                               \
    "TS:   " ts "\n"                                                    \
    "Msg:  \"" text "\"\n" >>                                           \
    ENVIRON["HOME"] "/.config/slacka/log.txt"
  
  exit 0
}

function list_conv(team, channel,     cmd, json, data, date, name, plus, msg, i, maxi, reactions) {

  read_users()

  cmd = "curl -L -s "                                               \
    "-H 'Authorization: Bearer " Token[team]  "' "                      \
    "'https://slack.com/api/conversations.history?channel=" channel "'"

  if (api(cmd))
    error("sending request failed")
  # walk_array(Data, "Data");

  # number of posts to report (default 10)
  for (i in Data["messages"])
    maxi++
  if (maxi >= 10)
    maxi = 10
  
  print ""
  for (i = maxi; i >= 1; i--) {
    if (Name[Data["messages"][i]["user"]])
      name = Name[Data["messages"][i]["user"]]
    else
      name = Data["messages"][i]["user"]
    if (Data["messages"][i]["latest_reply"])
      date = strftime("[%b-%d..",Data["messages"][i]["ts"])      \
        strftime("%b-%d]", Data["messages"][i]["latest_reply"])
    else
      date = strftime("[%b-%d %H:%M]",Data["messages"][i]["ts"])
    if (Data["messages"][i]["reply_count"])
      plus = "\x1b[38;5;12m(+" Data["messages"][i]["reply_count"] ")\x1b[0;m"
    else
      plus = "(+0)"
    
    if (isarray(Data["messages"][i]["reactions"]))
      reactions = "\x1b[38;5;10m{" length(Data["messages"][i]["reactions"]) \
        "}\x1b[0;m"
    else
      reactions = "{0}"

    # NB: apps (e.g., Element bidge) have no username TODO
    print "\x1b[38;5;11m" "<" name "> " "\x1b[0;m" plus " " reactions " " date \
      " ( " Data["messages"][i]["ts"] " )\n" 
    msg = gensub(/\n/," // ", "G", Data["messages"][i]["text"])
    msg_block(msg)
    print ""
  }
}

function thread(team, channel, ts,     name, cmd, json, data, msg, i, \
                reactions) {

  read_users()
  
  cmd = "curl -L -s "                                               \
    "-H 'Authorization: Bearer " Token[team]  "' "                        \
    "'https://slack.com/api/conversations.replies?channel=" channel "&"\
    "ts=" ts "'"
  
  if (api(cmd))
    error("sending request failed")
  # walk_array(Data, "Data");

  print ""
  PROCINFO["sorted_in"] = "@ind_num_asc"
  for (i in Data["messages"]) {
    if (Name[Data["messages"][i]["user"]])
      name = Name[Data["messages"][i]["user"]]
    else
      name = Data["messages"][i]["user"]

    if (isarray(Data["messages"][i]["reactions"]))
      reactions = "\x1b[38;5;10m{" length(Data["messages"][i]["reactions"]) \
        "}\x1b[0;m"
    else
      reactions = "{0}"

    print "\x1b[38;5;11m" "<" name ">" "\x1b[0;m" " " reactions  " "   \
      strftime("[%b-%d %a %H:%M] ",Data["messages"][i]["ts"]) "\n"
    msg = gensub(/\n/," // ", "G", Data["messages"][i]["text"])
    msg_block(msg)
    print ""
  }
}

function msg_block(msg,     j, lines, ec, bc, dash, width) {
  width = 70
  for (j in Name)   # names not in users.json are left as is
    gsub(("<@" j ">"), ("<@" Name[j] ">"), msg)
  lines = int((length(msg)-1) / width) + 1
  for (j = 1; j <= lines; j++) {
    ec = substr(msg,(j*width),1)
    bc = substr(msg,(j*width)+1,1)
    dash = (ec && (ec!=" ") && bc && (bc!=" ")) ? "-" : ""
    print "    " gensub(/^ */,"","G",substr(msg,((j-1)*width)+1,width)) dash
  }
}

function list_channels(channel,     cmd, json, data, i, c, C) {
  PROCINFO["sorted_in"] = "@ind_num_asc"

  read_users()

  if (channel)
    C[channel] = 1
  else
    for (i in Token)
      C[i] = 1
  
  for (c in C) {
    cmd = "curl -L -s -H 'Authorization: Bearer " Token[c]  \
      "' 'https://slack.com/api/conversations.list"         \
      "?types=public_channel,private_channel,im,mpim'"
    RS="\x04";
    cmd | getline json
    if (! json_fromJSON(json, data)) {
      print "JSON import failed!" > "/dev/stderr"
      exit 1
    }
    # walk_array(data, "data");

    print "TEAM: " TName[c] " (" c ")\n"  
    for (i in data["channels"]) {
      
      
      if (data["channels"][i]["is_im"]) {
        if (Name[data["channels"][i]["user"]])
          name = Name[data["channels"][i]["user"]]
        else if (data[channels][30][name])
          name = data["channels"][i]["user"]
        printf "  %-12s : IM with: %-40s\n", data["channels"][i]["id"], name
      }
      else if (data["channels"][i]["is_mpim"])
        printf "  %-12s : MPIM: %-50s\n", data["channels"][i]["id"], \
          data["channels"][i]["name"]
      else if (data["channels"][i]["is_channel"])
        printf "  %-12s : %-50s (priv=%s)\n", data["channels"][i]["id"], \
          data["channels"][i]["name"] , data["channels"][i]["is_private"]
    }
    print ""
  }
  exit 0
}

function team_names(team,   cmd, json, data) {
  cmd = "curl -L -s -H 'Authorization: Bearer " Token[team]   \
    "' 'https://slack.com/api/users.list?team_id=" team "'"
  RS="\x04";
  cmd | getline json
  if (! json_fromJSON(json, data)) {
    print "JSON import failed!" > "/dev/stderr"
    exit 1
  }
  
  for (i in data["members"])
    Name[data["members"][i]["id"]] = \
      data["members"][i]["profile"]["real_name_normalized"]
}

function walk_array(arr, name,      i, s) {
  for (i in arr) {
    if (isarray(arr[i]))
      walk_array(arr[i], (name "[" i "]"))
    else {
      # printf("%s[%s] = %s\n", name, i, arr[i])
      s = sprintf("%s[%s] = %s", name, i, arr[i])
      print gensub(/\[([^0-9][^]]*)\]/,"[\"\\1\"]","G",s)
    }
  }
}

function config(    json, data, i, j) {
  RS="\x04";
  getline json < (ENVIRON["HOME"] "/.config/slacka/config.json")
  if (! json_fromJSON(json, data)) {
    print "JSON import failed. Check for config at " ENVIRON["HOME"]    \
      "/.config/slacka/config.json" > "/dev/stderr"
    exit 1
  }
  # walk_array(data, "data")

  # Todo: add error checking
  for (i in data["teams"]) {
    Token[data["teams"][i]["id"]] = data["teams"][i]["token"]
    TName[data["teams"][i]["id"]] = data["teams"][i]["name"]
    
    for (j in data["teams"][i]["channels"]) {
      if (data["teams"][i]["channels"][j]["label"] ~ \
          /^(users|chans|cfg|check|auth|find|newim)$/) {
        print "Protected label: '" data["teams"][i]["channels"][j]["label"]\
          "'" > "/dev/stderr"
        exit 1
      }
      if (ChanID[data["teams"][i]["channels"][j]["label"]]) {
        print "Duplicate label: '" data["teams"][i]["channels"][j]["label"] \
          "'" > "/dev/stderr"
        exit 1
      }
      else {
        ChanID[data["teams"][i]["channels"][j]["label"]] =  \
          data["teams"][i]["channels"][j]["id"]

        ChanTeam[data["teams"][i]["channels"][j]["label"]] =    \
          data["teams"][i]["id"]

        if (typeof(data["teams"][i]["channels"][j]["check"]) == "number")
          if (!data["teams"][i]["channels"][j]["check"]) {
            # FIXME, move to index by channel code
            Skip[data["teams"][i]["channels"][j]["label"]] = 1
            SkipC[data["teams"][i]["channels"][j]["id"]] = 1
          }
      }
    }
  }
}

function read_users(    json, data, i) {
  RS="\x04";
  getline json < (ENVIRON["HOME"] "/.config/slacka/users.json")
  if (! json_fromJSON(json, data)) {
    print "JSON import failed. Check for " ENVIRON["HOME"]          \
      "/.config/slacka/users.json\n  Generate with: slacka users" > \
      "/dev/stderr"
    exit 1
  }
  
  for (i in data)
    Name[data[i]["id"]] = data[i]["name"]
}

function make_users(    cmd, json, data, name, i, j, redo) {
  for (i in Token) {
    printf "  %s " , TName[i]
    redo = 1
    while (redo) {
      cmd = "curl -L -s -H 'Authorization: Bearer " Token[i]    \
        "' 'https://slack.com/api/users.list?team_id=" i "&limit=1000"
      if (data["response_metadata"]["next_cursor"])
        cmd = cmd "&cursor=" data["response_metadata"]["next_cursor"]
      cmd = cmd "'"
      RS="\x04";
      cmd | getline json
      if (! json_fromJSON(json, data)) {
        print "JSON import failed!" > "/dev/stderr"
        exit 1
      }
      
      if (!data["ok"] == 1) {
        print "Reading failed"
        exit 1
      }
      else
        printf "OK "
    
      for (j in data["members"])
        name[data["members"][j]["id"]] =                        \
          data["members"][j]["profile"]["real_name_normalized"]
      
      if (!data["response_metadata"]["next_cursor"])
        # do not need another page
        redo = 0
    }
    printf "\n"
  }
  
  # Todo: check for directory
  json = "["
  for (i in name)
    json = json "{\"id\":\"" i "\",\"name\":\"" name[i] "\"},"
  json = substr(json,1,length(json)-1) "]"
  print json > (ENVIRON["HOME"] "/.config/slacka/users.json")
  print "Users updated successfully"

  exit 0
}

function ck_new(     status, i , cmd, label, newr, newp, newest, replies, \
                     json, data, newestrep) {

  RS="\x04";
  PROCINFO["sorted_in"] = "@ind_str_asc"
  printf "Checking:" 
  for (i in ChanID) {
    if (Skip[i])
      continue
    printf " %s", i 
    label[ChanID[i]] = i
    cmd = "curl -L -s "                                                 \
      "-H 'Authorization: Bearer " Token[ChanTeam[i]]  "' "             \
      "'https://slack.com/api/conversations.history?channel=" ChanID[i] "'"
    cmd | getline json
    if (! json_fromJSON(json, data)) {
      print "JSON import failed!" > "/dev/stderr"
      exit 1
    }

    # find the ts of the newset post:
    newest[ChanID[i]] = data["messages"][1]["ts"]
    if (data["messages"][1]["reply_count"])
      newestrep[ChanID[i]] = data["messages"][1]["reply_count"]
    else
      newestrep[ChanID[i]] = 0
    # for all posts in channel, make array of replies indexed by ts of post 
    for (j in data["messages"]) { 
      if (data["messages"][j]["reply_count"])
        replies[ChanID[i]][data["messages"][j]["ts"]] = \
          data["messages"][j]["reply_count"]
      else
        replies[ChanID[i]][data["messages"][j]["ts"]] = 0
    }
  }
  printf "\n"
  
  # test for latest.json
  "test -e " ENVIRON["HOME"] "/.config/slacka/latest.json ; echo $?"    \
    | getline status
  if (status) {
    print "Making initial " ENVIRON["HOME"] "/.config/slacka/latest.json"
  }
  else {
    getline json < (ENVIRON["HOME"] "/.config/slacka/latest.json")
    if (! json_fromJSON(json, data)) {
      print "JSON import failed."
      exit 1
    }

    for (i in data) {
      # is there either a new post, or a new reply to the last stored post
      if (data[i]["ts"] < newest[data[i]["id"]])
        newp[label[data[i]["id"]]]++
      if (data[i]["replies"] < replies[data[i]["id"]][data[i]["ts"]])
        newr[label[data[i]["id"]]]++
    }
    
    if (isarray(newp)) {
      printf "New posts: "
      for (i in newp)
        list = list " " i
      printf "%s\n", list
      list = ""
    }
    if (isarray(newr)) {
      printf "New replies in: "
      for (i in newr)
        list = list " " i
      printf "%s\n", list
    }
    if (!isarray(newr) && !isarray(newp))
      print "No new posts/replies"
  }

  # update latest.json
  json = "["
  for (i in newest)
    json = json "{\"id\":\"" i "\",\"ts\":\"" newest[i] "\",\"replies\":\"" \
      newestrep[i] "\"},"
  gsub(/.$/,"]",json)
  print json > (ENVIRON["HOME"] "/.config/slacka/latest.json")

  exit 0
}

function auth(   cmd) {

  # App setup (2021-02-19):
  #   1. Create app in a workspace, copy client ID and client secret 
  #   2. Add permissions -(see below)
  #   3. Add dummy redirect URL (e.g., https://example.com/path ), or webapp
  #      (https://camwebb.info/cgi/slackatoken)
  #   4. Confirm hardcode review
  #   5. Distribute
  # App can now be used in any authorized workspace

  # See: https://github.com/wee-slack/wee-slack/wee_slack.py
  #      https://github.com/erroneousboat/slack-term/wiki
  
  clientid       = "234851842290.1757541358103"
  
  print "In your browser, log in to a Slack workspace, then go to this URL:" \
    "\n\n   https://slack.com/oauth/v2/authorize?"                      \
    "client_id=" clientid "&user_scope="                                \
    "channels:history,channels:read,groups:history,groups:read,"        \
    "users:read,chat:write,search:read,reactions:write,"                \
    "im:read,im:history,im:write,"                                      \
    "mpim:read,mpim:history,mpim:write\n"
  print "After authorizing a workspace, you will be redirected to to a"
  print "  webapp that will display your token. If the webapp is not working"
  print "  see https://github.com/camwebb/slacka for other methods."

  # print "After authorizing a workspace, examine the URL in the redirect, and"  
  # print "paste the code string after 'code=' and before '&state='"
  # printf " : "
  # RS="\n";
  # getline code < "-"

  # RS="\x04";
  # cmd = "curl -s "                                                      \
  #   "'https://slack.com/api/oauth.v2.access?code=" code                 \
  #   "&client_id=" clientid                                              \
  #   "&client_secret=" clientsecret   "'"
  # cmd | getline json
  # if (! json_fromJSON(json, data)) {
  #   print "JSON import failed!" > "/dev/stderr"
  #   exit 1
  # }

  # if (!data["ok"] == "true") {
  #   print "Authorization failed."
  #   exit 1
  # }
  
  # print "\nNow enter JSON into the slacka config.json file, below team:"
  # print "{"
  # print "  \"id\"    : \"" data["team"]["id"] "\","
  # print "  \"name\"  : \"" data["team"]["name"] "\","
  # print "  \"token\" : \"" data["authed_user"]["access_token"] "\","
  # print "  \"channels\" :"
  # print "  ["
  # print "    {"
  # print "      \"label\" :  \"foo\","
  # print "      \"name\"  :  \"Dummy\","
  # print "      \"id\"    :  \"CXXXXXX\""
  # print "    }"
  # print "  ]"
  # print "}"

  exit 0
}

function find(team, channel, query,     cmd, json, data) {

  read_users()
  
  RS="\x04";
  cmd = "curl -s "                                                      \
    "-H 'Authorization: Bearer " Token[team]  "' "         \
    "'https://slack.com/api/search.messages?query=" query "'" 
  cmd | getline json
  if (! json_fromJSON(json, data)) {
    print "JSON import failed!" > "/dev/stderr"
    exit 1
  }

  PROCINFO["sorted_in"] = "@ind_num_desc"
  for (i in data["messages"]["matches"]) {
    if (data["messages"]["matches"][i]["channel"]["id"] == channel) {
      
      if (Name[data["messages"]["matches"][i]["user"]])
        name = Name[data["messages"]["matches"][i]["user"]]
      else
        name = data["messages"]["matches"][i]["user"]
      print "\x1b[38;5;11m" "<" name "> " "\x1b[0;m"                \
        strftime("[%b-%d %a %H:%M] ",data["messages"]["matches"][i]["ts"]) \
        " ( " data["messages"]["matches"][i]["ts"] " )\n" 
      msg = gensub(/\n/," // ", "G", data["messages"]["matches"][i]["text"])
      msg_block(msg)
      print ""
    }
  }
}
  
function error(msg) {
  print "Error: " msg > "/dev/stderr"
  exit 1
}

function api(cmd,     json) {
  
  RS="\x04";
  cmd | getline json
  if (! json_fromJSON(json, Data))
    error("JSON import failed!")
  
  if (!Data["ok"]) {
    if (DEBUG)
      walk_array(Data, "Data")
    return 1
  }
  else
    return 0
}

function read_latest(    status, json) {
  # test for latest.json
  
  "test -e " ENVIRON["HOME"] "/.config/slacka/latest.json ; echo $?"    \
    | getline status
  if (status)
    error("no latest.json file. Generate with slacka check")

  RS="\x04";

  getline json < (ENVIRON["HOME"] "/.config/slacka/latest.json")
  if (! json_fromJSON(json, Latest))
    error("JSON import failed.")

}
  
