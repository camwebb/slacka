#!/usr/bin/gawk -f

# Slacka: an Awk (Gawk) client for Slack
# https://github.com/camwebb/slacka
# (c) Cam Webb <cw@camwebb.info>
# License: The Unlicense <http://unlicense.org/>

@load "json" 

BEGIN{

  if ((ARGC == 2) && (ARGV[1] == "cfg")) {
    system("emacs " ENVIRON["HOME"] "/.config/slacka/config.json")
    exit 0
  }
  else if ((ARGC == 2) && (ARGV[1] == "auth")) {
    auth()
  }

  config()
  
  if (ARGC == 1) {
    print "Usage:\n  Maintenance: slacka auth | cfg | users | chans "
    print "  Check:       slacka ck"
    print "  Read:        slacka <channel> [ <thread_id> ]    "
    print "  Write:       slacka <channel> [ new | <thread_id> ]"\
      " \"your message\""
    print "  Search:      slacka <channel>  find  \"search term\""
    printf "    Chans: "
    PROCINFO["sorted_in"] = "@ind_str_asc"
    for (i in ChanID)
      printf "%s ", i
    print ""
    exit 0
  }

  else if (ARGC == 2) {
    # admin functions
    if (ARGV[1] == "users")
      make_users()
    else if (ARGV[1] == "chans")
      list_channels()
    else if (ARGV[1] == "ck")
      ck_new()

    # calling a channel
    else if (!ChanID[ARGV[1]]) {
      print "No such channel label" > "/dev/stderr"
      exit 1
    }
    else {
      read_users()
      # team_names(ChanTeam[ARGV[1]])
      list_conv(ChanTeam[ARGV[1]], ChanID[ARGV[1]])
    }
  }
  
  else if (ARGC == 3) {
    if (!ChanID[ARGV[1]]) {
      # this will catch a "new" or "find" post without text
      print "No such channel label" > "/dev/stderr"
      exit 1
    }
    else {
      read_users()
      # team_names(ChanTeam[ARGV[1]])
      thread(ChanTeam[ARGV[1]], ChanID[ARGV[1]], ARGV[2])
    }
  }

  else if (ARGC == 4) {
    if (!ChanID[ARGV[1]]) {
      print "No such channel label" > "/dev/stderr"
      exit 1
    }
    else if (ARGV[2] == "find") {
      read_users()
      find(ChanTeam[ARGV[1]], ChanID[ARGV[1]], ARGV[3])
    }
    else {
      post(ChanTeam[ARGV[1]], ChanID[ARGV[1]], ARGV[2], ARGV[3])
    }
  }

  else
    exit 1
}

function post(team, channel, ts, text,      cmd, json, data, newts, \
              status, lts, lrep) {
  cmd = "curl -X POST -L -s "                                     \
    "-H 'Authorization: Bearer " Token[team]  "' "                \
    "-H 'Content-type: application/x-www-form-urlencoded' "       \
    "--data-urlencode 'channel=" channel "' "                     \
    "--data-urlencode \"text=" text "\" "    
  if (ts != "new")
    cmd = cmd "--data-urlencode 'thread_ts=" ts "' "
  cmd = cmd "https://slack.com/api/chat.postMessage"

  # not needed "--data-urlencode 'as_user=true' "        

  RS="\x04";
  cmd | getline json
  if (! json_fromJSON(json, data)) {
    print "JSON import failed!" > "/dev/stderr"
    exit 1
  }

  if (!data["ok"]) {
    print "Posting failed"
    walk_array(data, "data");
    exit 1
  }
  print "Success"

  if (ts == "new")
    newts = data["ts"]

  # update latest.json - TODO, make this a function
  # test for latest.json
  "test -e " ENVIRON["HOME"] "/.config/slacka/latest.json ; echo $?"    \
    | getline status
  if (status) {
    print "No latest.json file. Generate with slacka ck"
    exit 1
  }
  
  getline json < (ENVIRON["HOME"] "/.config/slacka/latest.json")
  if (! json_fromJSON(json, data)) {
    print "JSON import failed."
    exit 1
  }

  for (i in data) {
    lts[data[i]["id"]] = data[i]["ts"]
    lrep[data[i]["id"]] = data[i]["replies"]
  }

  for (i in lts) {
    # if a new thread was started, register it
    if (newts) {
      lts[i] = newts
      lrep[i] = 0
    }
    # else if the new reply was to the last thread
    else if (lts[i] == ts) 
      lrep[i]++
  }

  # update latest.json
  json = "["
  for (i in lts)
    json = json "{\"id\":\"" i "\",\"ts\":\"" lts[i] "\",\"replies\":\"" \
      lrep[i] "\"},"
  gsub(/.$/,"]",json)
  print json > (ENVIRON["HOME"] "/.config/slacka/latest.json")
  
  exit 0
}

function list_conv(team, channel,     cmd, json, data, date, name, plus, msg, i) {
  
  # cmd = "curl -X POST -L -s "                               \
  #   "-H 'Authorization: Bearer " TOKEN  "' "                \
  #   "-H 'Content-type: application/x-www-form-urlencoded' " \
  #   "--data-urlencode 'channel=" channel "' "               \
  #   "https://slack.com/api/conversations.history"

  cmd = "curl -L -s "                                               \
    "-H 'Authorization: Bearer " Token[team]  "' "                      \
    "'https://slack.com/api/conversations.history?channel=" channel "'"
  
  RS="\x04";
  cmd | getline json
  if (! json_fromJSON(json, data)) {
    print "JSON import failed!" > "/dev/stderr"
    exit 1
  }
  # walk_array(data, "data");

  print ""
  for (i = 10; i >= 1; i--) {
    if (Name[data["messages"][i]["user"]])
      name = Name[data["messages"][i]["user"]]
    else
      name = data["messages"][i]["user"]
    if (data["messages"][i]["latest_reply"])
      date = strftime("[%m-%d..",data["messages"][i]["ts"])      \
        strftime("%m-%d]", data["messages"][i]["latest_reply"])
    else
      date = strftime("[%m-%d]",data["messages"][i]["ts"])
    if (data["messages"][i]["reply_count"])
      plus = "(+" data["messages"][i]["reply_count"] ")"
    else
      plus = "(+0)"

    print "\x1b[38;5;11m" "<" name "> " "\x1b[0;m" plus " " date           \
      " ( " data["messages"][i]["ts"] " )\n" 
    msg = gensub(/\n/," // ", "G", data["messages"][i]["text"])
    msg_block(msg)
    print ""
  }
}

function thread(team, channel, ts,     name, cmd, json, data, msg, i) {
  
  cmd = "curl -L -s "                                               \
    "-H 'Authorization: Bearer " Token[team]  "' "                        \
    "'https://slack.com/api/conversations.replies?channel=" channel "&"\
    "ts=" ts "'"
  
  RS="\x04";
  cmd | getline json
  if (! json_fromJSON(json, data)) {
    print "JSON import failed!" > "/dev/stderr"
    exit 1
  }
  # walk_array(data, "data");

  print ""
  PROCINFO["sorted_in"] = "@ind_num_asc"
  for (i in data["messages"]) {
    if (Name[data["messages"][i]["user"]])
      name = Name[data["messages"][i]["user"]]
    else
      name = data["messages"][i]["user"]
    print "\x1b[38;5;11m" "<" name "> " "\x1b[0;m" \
      strftime("[%m-%d %a %H:%M] ",data["messages"][i]["ts"]) "\n"
    msg = gensub(/\n/," // ", "G", data["messages"][i]["text"])
    msg_block(msg)
    print ""
  }
}

function msg_block(msg,     j, lines, ec, bc, dash, width) {
  width = 70
  for (j in Name)   # names not in users.json are left as is
    gsub(("<@" j ">"), ("<@" Name[j] ">"), msg)
  lines = int((length(msg)-1) / width) + 1
  for (j = 1; j <= lines; j++) {
    ec = substr(msg,(j*width),1)
    bc = substr(msg,(j*width)+1,1)
    dash = (ec && (ec!=" ") && bc && (bc!=" ")) ? "-" : ""
    print "    " gensub(/^ */,"","G",substr(msg,((j-1)*width)+1,width)) dash
  }
}

function list_channels(  cmd, json, data, i) {
  PROCINFO["sorted_in"] = "@ind_num_asc"

  for (c in Token) {
    cmd = "curl -L -s -H 'Authorization: Bearer " Token[c]  \
      "' 'https://slack.com/api/conversations.list"         \
      "?types=public_channel,private_channel'"
    RS="\x04";
    cmd | getline json
    if (! json_fromJSON(json, data)) {
      print "JSON import failed!" > "/dev/stderr"
      exit 1
    }
    # walk_array(data, "data");

    print "TEAM: " TName[c] " (" c ")"  
    for (i in data["channels"]) 
      printf "  %-12s : %-50s (priv=%s)\n", data["channels"][i]["id"], \
        data["channels"][i]["name"] , data["channels"][i]["is_private"]
    print ""
  }
}

function team_names(team,   cmd, json, data) {
  cmd = "curl -L -s -H 'Authorization: Bearer " Token[team]   \
    "' 'https://slack.com/api/users.list?team_id=" team "'"
  RS="\x04";
  cmd | getline json
  if (! json_fromJSON(json, data)) {
    print "JSON import failed!" > "/dev/stderr"
    exit 1
  }
  
  for (i in data["members"])
    Name[data["members"][i]["id"]] = \
      data["members"][i]["profile"]["real_name_normalized"]
}

function walk_array(arr, name,      i) {
  for (i in arr) {
    if (isarray(arr[i]))
      walk_array(arr[i], (name "[" i "]"))
    else
      printf("%s[%s] = %s\n", name, i, arr[i])
  }
}

function config(    json, data, i, j) {
  RS="\x04";
  getline json < (ENVIRON["HOME"] "/.config/slacka/config.json")
  if (! json_fromJSON(json, data)) {
    print "JSON import failed. Check for config at " ENVIRON["HOME"]    \
      "/.config/slacka/config.json" > "/dev/stderr"
    exit 1
  }
  # walk_array(data, "data")

  # Todo: add error checking
  for (i in data["teams"]) {
    Token[data["teams"][i]["id"]] = data["teams"][i]["token"]
    TName[data["teams"][i]["id"]] = data["teams"][i]["name"]
    
    for (j in data["teams"][i]["channels"]) {
      if (data["teams"][i]["channels"][j]["label"] ~ /^(users|chans|cfg|ck|auth|find)%/) {
        print "Protected label: '" data["teams"][i]["channels"][j]["label"]\
          "'" > "/dev/stderr"
        exit 1
      }
      if (ChanID[data["teams"][i]["channels"][j]["label"]]) {
        print "Duplicate label: '" data["teams"][i]["channels"][j]["label"] \
          "'" > "/dev/stderr"
        exit 1
      }
      else {
        ChanID[data["teams"][i]["channels"][j]["label"]] =  \
          data["teams"][i]["channels"][j]["id"]

        ChanTeam[data["teams"][i]["channels"][j]["label"]] =    \
          data["teams"][i]["id"]

        if (typeof(data["teams"][i]["channels"][j]["check"]) == "number")
          if (!data["teams"][i]["channels"][j]["check"])
            Skip[data["teams"][i]["channels"][j]["label"]] = 1
      }
    }
  }
}

function read_users(    json, data, i, j) {
  RS="\x04";
  getline json < (ENVIRON["HOME"] "/.config/slacka/users.json")
  if (! json_fromJSON(json, data)) {
    print "JSON import failed. Check for " ENVIRON["HOME"]          \
      "/.config/slacka/users.json\n  Generate with: slacka users" > \
      "/dev/stderr"
    exit 1
  }
  
  for (i in data)
    Name[data[i]["id"]] = data[i]["name"]
}

function make_users(    json, data, name, i, j) {
  for (i in Token) {
    cmd = "curl -L -s -H 'Authorization: Bearer " Token[i]  \
      "' 'https://slack.com/api/users.list?team_id=" i "'"
    RS="\x04";
    cmd | getline json
    if (! json_fromJSON(json, data)) {
      print "JSON import failed!" > "/dev/stderr"
      exit 1
    }

    for (j in data["members"])
      name[data["members"][j]["id"]] =                          \
        data["members"][j]["profile"]["real_name_normalized"]
  }
  
  # Todo: check for directory
  json = "["
  for (i in name)
    json = json "{\"id\":\"" i "\",\"name\":\"" name[i] "\"},"
  json = substr(json,1,length(json)-1) "]"
  print json > (ENVIRON["HOME"] "/.config/slacka/users.json")
  print "Users updated successfully"
  exit 0
}

function ck_new(     status, i , cmd, label, newr, newp, newest, replies, \
                     json, data, newestrep) {

  RS="\x04";
  PROCINFO["sorted_in"] = "@ind_str_asc"
  printf "Checking:" 
  for (i in ChanID) {
    if (Skip[i])
      continue
    printf " %s", i 
    label[ChanID[i]] = i
    cmd = "curl -L -s "                                                 \
      "-H 'Authorization: Bearer " Token[ChanTeam[i]]  "' "             \
      "'https://slack.com/api/conversations.history?channel=" ChanID[i] "'"
    cmd | getline json
    if (! json_fromJSON(json, data)) {
      print "JSON import failed!" > "/dev/stderr"
      exit 1
    }

    # find the ts of the newset post:
    newest[ChanID[i]] = data["messages"][1]["ts"]
    if (data["messages"][1]["reply_count"])
      newestrep[ChanID[i]] = data["messages"][1]["reply_count"]
    else
      newestrep[ChanID[i]] = 0
    # for all posts in channel, make array of replies indexed by ts of post 
    for (j in data["messages"]) { 
      if (data["messages"][j]["reply_count"])
        replies[ChanID[i]][data["messages"][j]["ts"]] = \
          data["messages"][j]["reply_count"]
      else
        replies[ChanID[i]][data["messages"][j]["ts"]] = 0
    }
  }
  printf "\n"
  
  # test for latest.json
  "test -e " ENVIRON["HOME"] "/.config/slacka/latest.json ; echo $?"    \
    | getline status
  if (status) {
    print "Making initial " ENVIRON["HOME"] "/.config/slacka/latest.json"
  }
  else {
    getline json < (ENVIRON["HOME"] "/.config/slacka/latest.json")
    if (! json_fromJSON(json, data)) {
      print "JSON import failed."
      exit 1
    }

    for (i in data) {
      # is there either a new post, or a new reply to the last stored post
      if (data[i]["ts"] < newest[data[i]["id"]])
        newp[label[data[i]["id"]]]++
      if (data[i]["replies"] < replies[data[i]["id"]][data[i]["ts"]])
        newr[label[data[i]["id"]]]++
    }
    
    if (isarray(newp)) {
      printf "New posts: "
      for (i in newp)
        list = list " " i
      printf "%s\n", list
      list = ""
    }
    if (isarray(newr)) {
      printf "New replies in: "
      for (i in newr)
        list = list " " i
      printf "%s\n", list
    }
    if (!isarray(newr) && !isarray(newp))
      print "No new posts/replies"
  }

  # update latest.json
  json = "["
  for (i in newest)
    json = json "{\"id\":\"" i "\",\"ts\":\"" newest[i] "\",\"replies\":\"" \
      newestrep[i] "\"},"
  gsub(/.$/,"]",json)
  print json > (ENVIRON["HOME"] "/.config/slacka/latest.json")
  exit 0
  
}

function auth(   cmd) {

  # App setup (2021-02-19):
  #   1. Create app in a workspace, copy client ID and client secret 
  #   2. Add permissions -> User scopes: channels:history, channels:read,
  #        groups:history, groups:read, users:read, calls:write
  #   3. Add dummy redirect URL (e.g., https://example.com/path )
  #   4. Confirm hardcode review
  #   5. Distribute
  # App can now be used in any authorized workspace

  # YES! there is a 'secret' revealed here. But without the CODE,
  #   generated during the user permission phase, and the subsequent
  #   TOKEN, there is no way for a third party to eavesdrop or post as a user.
  # See: https://github.com/wee-slack/wee-slack/wee_slack.py
  #      https://github.com/erroneousboat/slack-term/wiki
  
  clientid       = "234851842290.1757541358103"
  clientsecret  = "0832b70040d2f885716185fa190d7b5d"
  
  print "In your browser, log in to a Slack workspace, then go to this URL:" \
    "\n\n   https://slack.com/oauth/v2/authorize?"                        \
    "client_id=" clientid "&user_scope=channels:history,"\
    "channels:read,groups:history,groups:read,users:read,"\
    "chat:write,search:read\n"
  print "After authorizing a workspace, examine the URL in the redirect, and"  
  print "paste the code string after 'code=' and before '&state='"
  printf " : "
  RS="\n";
  getline code < "-"

  RS="\x04";
  cmd = "curl -s "                                                      \
    "'https://slack.com/api/oauth.v2.access?code=" code                 \
    "&client_id=" clientid                                              \
    "&client_secret=" clientsecret   "'"
  cmd | getline json
  if (! json_fromJSON(json, data)) {
    print "JSON import failed!" > "/dev/stderr"
    exit 1
  }

  if (!data["ok"] == "true") {
    print "Authorization failed."
    exit 1
  }
  
  print "\nNow enter JSON into the slacka config.json file, below team:"
  print "{"
  print "  \"id\"    : \"" data["team"]["id"] "\","
  print "  \"name\"  : \"" data["team"]["name"] "\","
  print "  \"token\" : \"" data["authed_user"]["access_token"] "\","
  print "  \"channels\" :"
  print "  ["
  print "    {"
  print "      \"label\" :  \"foo\","
  print "      \"name\"  :  \"Dummy\","
  print "      \"id\"    :  \"CXXXXXX\""
  print "    }"
  print "  ]"
  print "}"

  exit 0

}

function find(team, channel, query,     cmd, json, data) {
  RS="\x04";
  cmd = "curl -s "                                                      \
    "-H 'Authorization: Bearer " Token[team]  "' "         \
    "'https://slack.com/api/search.messages?query=" query "'" 
  cmd | getline json
  if (! json_fromJSON(json, data)) {
    print "JSON import failed!" > "/dev/stderr"
    exit 1
  }

  PROCINFO["sorted_in"] = "@ind_num_desc"
  for (i in data["messages"]["matches"]) {
    if (data["messages"]["matches"][i]["channel"]["id"] == channel) {
      
      if (Name[data["messages"]["matches"][i]["user"]])
        name = Name[data["messages"]["matches"][i]["user"]]
      else
        name = data["messages"]["matches"][i]["user"]
      print "\x1b[38;5;11m" "<" name "> " "\x1b[0;m"                \
        strftime("[%m-%d %a %H:%M] ",data["messages"]["matches"][i]["ts"]) \
        " ( " data["messages"]["matches"][i]["ts"] " )\n" 
      msg = gensub(/\n/," // ", "G", data["messages"]["matches"][i]["text"])
      msg_block(msg)
      print ""
    }
  }
}
  
